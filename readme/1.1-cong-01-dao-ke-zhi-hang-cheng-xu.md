# 1-1 性能-CPU

## 主要性能指标

1. 响应时间（Response time）或者叫执行时间（Execution time）：工作
2. **吞吐率**（Throughput）或者带宽（Bandwidth）：传输

### SPEC

* **SPEC**（Standard Performance Evaluation Corporation）：各大CPU 和服务器厂商组织的第三方机构，专门用来指定各种“跑分”的规则
* 通过数十个不同的计算程序，对于 CPU 的性能给出一个最终评分。这些程序丰富多彩，有编译器、解释器、视频压缩、人工智能国际象棋等等，涵盖了方方面面的应用场景
* [SPEC - Standard Performance Evaluation Corporation](https://www.spec.org/)

## 计算机的计时单位：CPU 时钟

* 计算响应时间中的两个问题

#### 1. 测不准

* 原因
  * 统计时间是通过记录程序运行结束的时间减去程序开始运行的时间，这个时间也叫 Wall Clock Time 或者 Elapsed Time
  * 但计算机可能同时运行着好多个程序，CPU 实际上不停地在各个程序之间进行切换，在这些时间里面，很可能 CPU 切换去运行别的程序了
  * 而且有些程序在运行的时候，可能要从网络、硬盘去读取数据，要等网络和硬盘把数据读出来，给到内存和 CPU
  * 所以要想准确统计某个程序运行时间，进而去比较两个程序的实际性能，我们得把这些时间给刨除掉
* 解决方法：剔除多余时间
  * Linux 下有一个叫 time 的命令，可以帮我们统计在同样的 Wall Clock Time 下，程序实际在 CPU 上到底花了多少时间
  *   运行一下 time 命令，它会返回三个值

      * 第一个是real time，也就是我们说的 Wall Clock Time，也就是运行程序整个过程中流逝掉的时间
      * 第二个是user time，也就是 CPU 在运行你的程序，在用户态运行指令的时间
      * 第三个是sys time，是 CPU 在运行你的程序，在操作系统内核里运行指令的时间
      * 程序实际花费的 CPU 响应时间（CPU Time），就是 user time 加上 sys time。
        * 以下例子中，程序实际上用了 0.101s，但是 CPU time 只有 0.031+0.016 = 0.047s
        * 运行程序的时间里，只有不到一半是实际花在这个程序上的

      ```bash
      $ time seq 1000000 | wc -l

      1000000
      real 0m0.101s
      user 0m0.031s
      sys 0m0.016s
      ```

#### 2. 时间与CPU运行情况有关

* 原因
  * 即使在同一台计算机上，CPU 可能满载运行也可能降频运行，降频运行的时候自然花的时间会多一些
  * 除了 CPU 之外，时间这个性能指标还会受到主板、内存这些其他相关硬件的影响
* 解决方法：将时间拆解后再计算
  * 把程序的 CPU 响应时间拆解成 CPU 时钟周期数（CPU Cycles）和 时钟周期时间（Clock Cycle）的乘积
  * 即：程序的 CPU 响应时间 =CPU 时钟周期数×时钟周期时间
  * 时钟周期时间：1/CPU 的主频
    * 超频
      * 相当于把买回来的 CPU 内部的钟给调快了，于是 CPU 的计算跟着这个时钟的节奏，也就自然变快了
      * 这个快是有代价的，CPU 跑得越快，散热的压力也就越大。超过其极限，CPU 就会崩溃
    * 例：Intel Core-i7-7700HQ 2.8GHz
      * 这里的 2.8GHz 就是电脑的主频（Frequency/Clock Rate）
      * 这个 2.8GHz，我们可以粗浅地认为，CPU 在 1 秒时间内，可以执行的简单指令的数量是 2.8G 条
      * 它代表 CPU 能够识别出来的最小的时间间隔
  * CPU 时钟周期数：指令数×**每条指令的平均时钟周期数**（Cycles Per Instruction，简称 CPI）
    * 不同的指令需要的 Cycles 是不同的
      * 例：加法和乘法都对应着一条 CPU 指令，但是乘法需要的 Cycles 就比加法要多，自然也就慢
    * CPU 响应时间 = 指令数×每条指令的平均时钟周期数×时钟周期时间

### 性能优化方法

#### 提高吞吐率

* 缩短响应时间，即让一段时间内进行更多次数据传输
* 多核同时处理数据

#### 缩短响应时间

**性能参数分解**

* 性能 = 1 / 响应时间
* CPU 响应时间 = 指令数×每条指令的平均时钟周期数×时钟周期时间
* 时钟周期时间：1/CPU 的主频

**优化路径**

1. 时钟周期时间：提升计算机主频，这个取决于计算机硬件，需要更换更好的CPU或进行超频
2. 每条指令的平均时钟周期数 CPI：现代的 CPU 通过流水线技术（Pipeline），让一条指令需要的 CPU Cycle 尽可能地少
3. 指令数：这个很多时候是在编译器上的挑战。同样的代码，编译成计算机指令时候就有各种不同的表示方式

#### 小结

我们可以把自己想象成一个 CPU，坐在那里写程序。

计算机主频就好像是你的打字速度，打字越快，你自然可以多写一点程序。

CPI 相当于你在写程序的时候，熟悉各种快捷键，越是打同样的内容，需要敲击键盘的次数就越少。

指令数相当于你的程序设计得够合理，同样的程序要写的代码行数就少。

如果三者皆能实现，你自然可以很快地写出一个优秀的程序，你的“性能”从外面来看就是好的。
